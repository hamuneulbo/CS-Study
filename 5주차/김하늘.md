# 5주차 CS 스터디 

## 1. CPU 스케줄링

## 2. 캐시(Cache)란

## 3. 데드락(DeadLock)

## 4. Race Condition

## 5. 세마포어(Semaphore) & 뮤텍스(Mutex)

## 6. 페이징 & 세그멘테이션

## 7. 페이지 교체 알고리즘

=======


* 여러 프로세스가 있고, 이 프로세스 들이 자원을 동시에 요구하는데 자원은 한정되어 있다. 이때 자원을 어떻게 나눠줄 것인지에 대한 정책을 말한다.
* CPU 스케줄링은 실행->대기, 실행->준비, 대기->준비, 종료 시 발생한다.
* CPU 스케줄링 알고리즘의 평가 기준
  * CPU 사용률 : 전체 시스템 시간 중 CPU가 작업을 처리하는 시간의 비율이다.
  * 처리량 : CPU가 단위 시간당 작업을 마친 프로세스의 수이다.
  * 응답시간 : 대화식 시스템에서 요청 후 응답이 오기 시작할 때까지의 시간이다.
  * 대기시간 : 프로세스가 준비 큐에서 대기하는 시간들의 총합이다.
  * 반환시간 : 대기시간 + 실행 시간. 즉, 프로세스의 시작부터 끝날 때까지 걸리는 시간이다.
* CPU 스케줄링 알고리즘 종류
  * 비선점형 스케줄링 : 프로세스가 자발적으로 대기로 넘어가거나 종료될 때까지 CPU를 점유하는 방식이다.
    * FCFS (First Come First Served) : 먼저 자원을 요청한 프로세스들이 큐에 들어가고 스케줄러는 먼저 온 프로세스를 선택해서 CPU 자원을 할당한다.
    * SJF (Shortest Job First) : 최단시간으로 처리될 수 있는 프로세스에 우선순위를 준다.
    * HRN (Highest Response Ratio Next) : 서비스를 받기 위해 대기한 시간에 우선순위 가중치를 부여한다. 
  * 선점형 스케줄링 : 운영체제가 더 높은 우선순위에 강제적으로 CPU 자원을 할당할 수 있는 스케줄링이다.
    시분할 시스템을 고려하여 만든 알고리즘이다.
    * Round Robin : 프로세스는 할당받은 시간 동안 작업을 진행하다가 작업을 마치지 못하면 준비 큐의 맨 뒤로 간다.
    * Shortest Remaining Time : 남아있는 작업 시간이 적은 프로세스를 준비 큐에서 선택한다.
    * 다단계 큐 : 준비 큐를 여러 개 사용하는 기법이다. 각각의 큐는 자신의 스케줄링 알고리즘을 수행하며, 큐와 큐 사이에도 우선순위를 부여한다.
    * 다단계 피드백 큐 : 다단계 큐와 비슷하나 프로세스들이 큐를 이동할 수 있다.


###### 참고
* [CPU 스케줄링 알고리즘 [ 운영체제(OS) 면접 질문 4]](https://murphymoon.tistory.com/entry/CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-4)


## 2. 캐시(Cache)란



* **자주 사용하는 데이터를 원래 저장된 곳보다 속도가 더 빠른 임시 저장소(캐시)에 저장해서 데이터를 빠르게 읽어올 수 있게끔 하는 것이다.**
* 캐시가 효율적으로 작동하려면, 캐시에 저장되는 데이터들이 지역성을 가져야 한다.
  * **공간적 지역성** : 대부분 프로그램은 참조한 주소와 인접한 주소의 내용을 다시 한 번 더 참조하는 특성이 있다.
  * **시간적 지역성** : 한 번 참조한 주소를 다시 한 번 재참조하는 특성이 있다.



###### 참고

* [[운영체제] 한번에 모아보는 면접대비 운영체제 질문 목록들](https://chanhuiseok.github.io/posts/cs-3/)



## 3. 데드락(DeadLock)



* 데드락 또는 교착상태란 **한정된 자원을 여러 프로세스가 사용하고자 할 때 발생하는 상황**으로, **프로세스가 자원을 얻기 위해 영구적으로 기다리는 상태**이다.

* 임계 영역(Critical Section)은 둘 이상의 실행 주체가 동시에 접근해서는 안되는 영역이다.

  임계 영역에 동시에 접근해 데드락이 발생하는 문제를 예방하기 위해서 세마포어나 뮤텍스를 사용 가능하다.



###### 참고

* [[기술면접] CS 기술면접 질문 - 운영체제 (5/8)](https://mangkyu.tistory.com/92)

  

## 4. Race Condition (경쟁 상태)



* **둘 이상의 입력 또는 조작의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태**이다.
* 공유 자원을 둘 이상의 스레드 혹은 프로세스가 읽거나 쓰면서 결과값이 의도와 달라질 수 있는 문제이다.
* **문제점**
  * 예측 불가능한 결과
  * 일관성 손실
  * 디버깅의 어려움
  * 긴 대기 시
* **예방법**
  * 상호 배제 : 공유 데이터레 접근하는 부분을 임계 영역으로 정하고, 한 번에 하나의 실행 흐름만 해당 영역에 들어가도록 한다.
  * 공유 데이터를 최소환한 병렬 처리 설계 : 데이터를 적절히 분리해 각 스레드가 독립적으로 처리하도록 한다.
  * 스레드 안정성 보장 
  * 테스트와 검증 



###### 참고

* [[CS] Race condition이란?](https://velog.io/@yarogono/CS-Race-condition%EC%9D%B4%EB%9E%80)

  

## 5. 세마포어(Semaphore) & 뮤텍스(Mutex)



* 동시성 프로그래밍의 가장 큰 숙제인 "**공유자원 관리**"를 위해서는, **상호배제 기법**이 필요한데 세마포어와 뮤텍스와 이를 위해 고안된 기법이다.
  * 상호 배제 : 공유 자원을 어느 시점에서 단지 한 개의 프로세스만이 사용할 수 있도록 하며, 다른 프로세스가 공유자원에 대하여 접근하지 못하게 제어하고 각 프로세스가 번갈아 가며 공유 자원을 사용하도록 한다.

#### ▶ 세마포어란?

* **현재 공유 자원에 접근할 수 있는 쓰레드, 프로세스의 수를 나타내는 값**을 두어 상호배제를 달성하는 기법이다.

#### ▶ 뮤텍스란?

* **임계 영역을 가진 쓰레드들의 실행 시간이 겹치지 않게, 각각 단독으로 실행**하게 하는 기술이다. 즉, 뮤텍스 객체를 두 쓰레드가 동시에 이용할 수 없다.

#### ▶ 차이점은?

* 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다.

* 세마포어는 소유할 수 없지만, 뮤텍스는 소유 가능하며, 소유주가 이에 대한 책임을 진다.

* 뮤텍스는 이를 소유하고 있는 쓰레드가 뮤텍스를 해제할 수 있다. 

  반면, 세마포어는 이를 소유하고 있지 않은 쓰레드가 세마포어를 해제할 수 있다.

* 세마포어는 시스템 범위에 걸쳐 있어 파일 시스템상의 파일 형태로 존재한다.

  뮤텍스는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 clean 된다.

* **동기화 대상의 개수의 차이**

  뮤텍스는 동기화 대상이 오직 하나 뿐일 때 사용

  세마포어는 동기화 대상이 하나 이상일 때 사용



###### 참고

* [[ 기술면접 / 운영체제] 세마포어(Semaphore) & 뮤텍스(Mutex)](https://jokerkwu.tistory.com/126)



## 6. 페이징 & 세그멘테이션



####  ▶ 페이징

* **프로세스를 일정한 크기의 페이지로 분할해서 메모리에 적재하는 방식**이다.
  * 페이지 : 고정 사이즈의 가상 메모리 내 프로세스 조각
* 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없앤 메모리 관리 방법이다.

* **장점**

  * 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고, 물리 메모리의 남는 프레임에 적절히 배치되기 때문에 외부 단편화가 발생하지 않는다.

* **단점**

  * 내부 단편화 문제가 발생 가능하다. 페이지 단위를 작게하면 해결할 수 있지만, 페이지 매핑 과정이 복잡해서 비효율적이다.

  

#### ▶ 세그멘테이션

* **프로세스를** 물리적 단위인 페이지가 아닌, **논리적 단위인 세그먼트로 분할해서 메모리에 적재하는 방식**이다.

  * 세그먼트 : 가상 메모리를 서로 크기가 다른 논리적 단위로 분할한 것이다.

    의미가 같지 않는 논리적 내용을 기준으로 프로그램을 분할해서 크기가 같지 않다.

* **장점**

  * 내부 단편화 문제가 해소된다.

  * 보호와 공유 기능을 수행할 수 있다.

    프로그램의 중요한 부분과 중요하지 않은 부분을 분리하여 저장할 수 있고, 같은 코드 영역은 한 번에 저장할 수 있다.

* **단점**

  * 외부 단편화 문제가 생길 수 있다.



###### 참고

* [[운영체제] 페이징과 세그멘테이션](https://steady-coding.tistory.com/524)



## 7. 페이지 교체 알고리즘



* 페이징 기법으로 메모리를 관리하는 운영체제에서 **필요한 페이지가 주기억장치에 적재되지 않았을 때, 어떤 페이지 프레임을 선택해 교체할 것인지 결정하는 방법이다.**
* **종류**
  * FIFO (First In First Out) : 메모리에 올라온 지 가장 오래된 페이지를 교체한다.
  * Optimal (최적) 페이지 교체 : 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 알고리즘이다. 선행조건은 프로세스가 앞으로 사용할 페이지를 미리 알아야 한다는 것이다. 이는 실제 상황에서는 알 수 없기 때문에 구현이 불가능하다.
  * **LRU (Least Recently Used)** : 가장 오래 사용되지 않은 페이지를 교체하는 알고리즘이다. 
  * LFU (Least Frequently Used) : 참조 횟수가 가장 작은 페이지를 교체하는 알고리즘이다.



###### 참조

* [[신입 개발자 기술 면접] 운영체제](https://baebalja.tistory.com/432)
