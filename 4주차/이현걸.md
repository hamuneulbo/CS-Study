## CS 스터디 4주차

### 운영체제란
* 운영체제(OS)는 컴퓨터 자원 관리와 사용자 편의성을 제공하는 프로그램 모임으로, 하드웨어 자원 효율 관리, 응용 프로그램 인터페이스 역할, 시스템 제어를 담당하는 시스템 소프트웨어이다. 주어진 자원으로 최대 성능 확보와 동시에 형평성 유지 역할을 수행한다.

### 프로세스 vs 스레드
* 프로세스는 컴퓨터에서 실행 중인 프로그램을 나타내며, 메모리에 적재되어 실행되는 작업의 단위이다. 각 프로세스는 독립적인 주소 공간을 가지며 스택, 데이터, 코드, 힙과 같은 메모리 영역을 포함하고 있으며, 이러한 정보는 PCB(Process Control Block)라고 불리는 자료구조에 저장된다. Context Switching이 발생할 때 PCB에 중요한 정보가 저장된다.

* 스레드는 하나의 프로세스 내에서 실행되는 여러 실행 흐름의 단위이다. 프로세스가 할당받은 자원을 공유하면서 작업을 수행하며, 주로 스레드는 스택만을 별도로 할당받고 코드, 데이터, 힙 영역은 공유한다. 이러한 독립적인 스택 할당은 함수 호출과 지역 변수 관리를 위한 것으로, 각 스레드가 독립적인 실행 흐름을 가질 수 있게 한다. 또한, PC(Program Counter)는 독립적으로 할당되어 각 스레드의 실행 지점을 기억하고 독립적인 실행을 지원한다.

* 프로세스와 스레드는 각각 장단점을 가지고 있으며, 선택은 상황과 요구에 따라 달라질 수 있다. 프로세스는 독립성이 높고 안정성을 보장하지만 자원 소모가 크고 통신 비용이 높을 수 있다. 반면, 스레드는 자원 공유와 효율적인 작업 전환을 제공하지만 동기화 문제와 오류에 민감할 수 있다.

### 프로세스 주소 공간
프로세스의 주소 영역은 크게 코드(Code), 데이터(Data), BSS, 스택(Stack), 그리고 힙(Heap) 영역으로 나눌 수 있다.

1. 코드(Code) 영역:
   - 프로그램의 실행 코드가 저장되는 공간으로, 읽기 전용(read-only)이다.
   - 컴퓨터가 실행할 명령어들이 포함되어 있으며, 프로그램이 실행될 때 변하지 않는 공간이다.

2. 데이터(Data) 영역:
   - 전역 변수와 정적 변수와 같은 데이터가 저장되는 공간이다.
   - 읽기와 쓰기가 가능하며, 프로그램이 실행 중에 데이터를 변경할 수 있다.

3. BSS (Block Started Symbol) 영역:
   - 초기값이 없는 전역 변수, 배열, 정적 변수가 저장되는 공간이다.
   - 초기화되지 않은 값은 BSS 영역에 저장되며, 초기화된 값은 Data 영역에 저장된다.

4. 스택(Stack) 영역:
   - 함수와 지역 변수, 매개변수 등이 저장되는 공간이다.
   - 함수 호출 및 반환에 따라 크기가 동적으로 변하며, 후입선출(LIFO) 방식으로 데이터를 저장한다.
   - 스택 포인터를 이용하여 데이터를 저장하고 반환하기 때문에 구현이 간단하고 빠르다.
   - 그러나 스택의 크기에는 제한이 있으며, 재귀 함수 호출이 과도하게 이루어질 경우 스택 오버플로우 문제가 발생할 수 있다.

5. 힙(Heap) 영역:
   - 런타임 시에 크기가 동적으로 결정되는 영역으로, 메모리를 동적으로 할당하고 해제할 때 사용된다.
   - 주로 동적으로 생성된 객체나 데이터 구조가 저장되며, 프로그래머가 직접 메모리를 관리해야 한다.
   - 힙은 낮은 주소에서 높은 주소 방향으로 할당되며, 스택과 반대 방향으로 확장된다.

이러한 주소 영역 분할은 프로세스의 메모리 관리와 데이터 접근을 효율적으로 처리하기 위한 목적으로 사용된다. 각 영역은 다른 특성과 제약사항을 가지고 있으며, 이를 적절하게 활용하여 프로그램을 설계하고 최적화하는데 중요한 역할을 한다.

### 멀티스레드(Multi Thread)
멀티쓰레딩(Multithreading)은 하나의 프로세스 내에서 여러 개의 쓰레드(Thread)가 동시에 실행되는 기술이다. 각 쓰레드는 프로세스의 자원을 공유하면서 독립적으로 실행된다. 이때, 프로세스는 하나의 실행 단위를 나타내며, 쓰레드는 이 프로세스 내에서 실행되는 각각의 작업 단위를 나타낸다.

멀티쓰레딩을 사용하는 이유와 주요 특징은 다음과 같다:

1. **병렬성과 동시성**: 멀티쓰레딩을 통해 여러 작업을 병렬로 수행할 수 있다. 이는 프로그램의 실행 속도를 향상시키는 데 도움을 준다. 또한, 다양한 작업을 동시에 처리할 수 있어 더 효율적인 프로그램을 개발할 수 있다.

2. **자원 공유**: 멀티쓰레딩은 하나의 프로세스 내에서 쓰레드들이 메모리 공간을 공유한다. 이로써 데이터와 자원에 대한 공유와 효율적인 데이터 교환을 가능하게 한다.

3. **경제성**: 멀티프로세스(Multiprocessing)와 비교하면, 멀티쓰레딩은 쓰레드 간의 통신 및 자원 공유가 더 간단하므로 자원 소비가 적다.

4. **반응성 향상**: 멀티쓰레딩을 사용하면 한 쓰레드에서 블록되거나 대기 상태에 빠져도 다른 쓰레드는 계속 실행되므로 전체 프로그램의 반응성이 향상된다.

멀티쓰레딩은 주로 다음과 같은 상황에서 사용된다:

- **다중 작업 처리**: 여러 작업이 동시에 발생하거나 동시에 처리되어야 할 때, 각 작업을 별도의 쓰레드로 처리하여 성능을 향상시킨다.

- **UI 응답성 향상**: 그래픽 사용자 인터페이스(GUI)를 가진 응용 프로그램에서 멀티쓰레딩을 사용하여 UI의 응답성을 높인다. 사용자 인터랙션을 처리하는 쓰레드와 백그라운드 작업을 처리하는 쓰레드를 분리하여 UI가 끊기지 않고 반응할 수 있게 한다.

- **네트워크 통신**: 네트워크 통신 작업을 처리할 때, 입출력(I/O) 작업이 블록되는 것을 방지하고 동시에 여러 클라이언트 요청을 처리하기 위해 멀티쓰레딩을 사용한다.

- **다중 코어(CPU) 활용**: 멀티코어 CPU를 활용하여 작업을 분산 처리하고 성능을 최적화한다.

멀티쓰레딩을 구현하기 위해서는 쓰레드 간 동기화, 데드락(Deadlock) 방지 등과 같은 다양한 도구와 기술을 이해하고 활용해야 한다. 또한, 쓰레드 간의 안정성과 데이터 무결성을 보장하기 위한 주의가 필요하다.


### 인터럽트(Interrupt)
인터럽트는 프로그램 실행 중에 예외 상황이나 하드웨어 장치의 요청 등이 발생할 때, CPU에게 알려서 처리할 수 있도록 하는 메커니즘이다. 인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트(트랩) 두 가지 주요 유형으로 나뉜다.

**하드웨어 인터럽트**:
하드웨어 장치에서 발생하는 인터럽트로, 주로 시스템의 동작과 관련된 하드웨어 이벤트를 처리한다. 대표적인 하드웨어 인터럽트로는 타이머 인터럽트가 있으며, CPU는 내장된 타이머를 사용하여 일정한 주기마다 타이머 인터럽트를 발생시켜서 운영체제(OS)가 제어권을 갖도록 한다.

**소프트웨어 인터럽트(트랩)**:
* 소프트웨어에서 발생하는 인터럽트로, 주로 프로그램 실행 중에 예외 상황이나 특정한 명령어가 실행되어야 하는 경우를 처리한다. 예를 들어, 시스템 콜(system call)이나 예외(exception)가 소프트웨어 인터럽트의 예시이다. 시스템 콜은 사용자가 특정한 권한이 필요한 명령어를 실행하려고 할 때 사용되며, 예외는 0으로 나누기, 오버플로우 등과 같이 예상치 못한 상황에서 발생한다.

* 인터럽트 동작 순서는 다음과 같다:
1. 인터럽트 요청: 하드웨어나 소프트웨어에서 인터럽트가 요청된다.
2. 프로그램 실행 중단: 현재 실행 중인 작업이 중단되고, 현재까지의 상태가 보존된다.
3. 현재 프로그램 상태 보존: 프로세스 제어 블록(PCB)에 현재 프로그램 카운터(PC)와 관련된 정보가 저장된다.
4. 인터럽트 처리 루틴 실행: 인터럽트가 요청된 장치를 식별하고 해당 인터럽트 서비스 루틴(ISR)을 실행한다.
5. ISR 실행: 실질적인 작업을 수행하며, 다른 인터럽트가 발생할 경우 우선순위에 따라 재귀적으로 처리한다.
6. 상태 복구: 인터럽트 이전의 상태로 돌아가기 위해 PCB의 정보를 사용하여 복구한다.
7. 중단된 프로그램 실행: 중단된 프로그램을 이전에 수행 중이던 지점부터 다시 실행한다.

인터럽트는 프로그램 실행 흐름을 중단하고 다른 작업을 수행하도록 하는 중요한 메커니즘으로, 하드웨어 및 소프트웨어의 이벤트 처리와 운영체제의 관리에 핵심적으로 사용된다.

### 시스템 콜(System Call)
* 운영체제(OS)는 커널 모드(Kernel Mode)와 사용자 모드(User Mode)로 구동된다. 이 구분은 특정한 기능이 커널 모드에서만 동작하도록 하는 중요한 역할을 한다. 예를 들어, 파일 읽기와 쓰기와 같은 작업은 주로 시스템 콜(System Call)을 통해 이루어진다. 이러한 시스템 콜은 프로세스가 하드웨어에 직접 접근하여 필요한 기능을 사용할 수 있도록 한다.

* 프로세스 제어, 파일 조작, 장치 관리, 통신 등과 같은 시스템 콜은 다양한 작업을 수행하기 위해 사용된다. 이러한 작업이 실행되려면 아래와 같은 순서로 동작한다:

1. 사용자 모드(User Mode)에서 실행 중인 프로세스가 시스템 콜을 호출한다.
2. 시스템 콜이 실행되면 권한을 바꾸기 위해 trap 명령을 사용하며, 작업이 완료되면 OS는 return-from-trap 명령을 통해 원래의 권한으로 복귀한다.
3. trap 명령이 실행되면 프로세스는 프로그램 카운터(PC), 플래그, 레지스터 정보 등을 커널 스택에 저장한다.
4. 이후 return-from-trap 명령이 실행되면 저장된 데이터를 모두 꺼내어 User mode에서 사용할 수 있도록 한다.

* 운영체제는 이러한 커널 영역의 기능을 사용자 모드가 활용할 수 있도록 하여 프로세스가 하드웨어에 접근하여 필요한 기능을 사용할 수 있도록 한다.

* 또한, 소프트웨어 인터럽트는 운영체제에서 작동시키는 인터럽트를 나타내며, 프로세스가 운영체제로부터 모든 권한을 받아 실행되는 상황에서 발생한다. 이런 실행 방식은 컨텍스트 스위칭이 발생하지 않아 속도가 빠르지만, 무한 루프와 같은 상황이 발생하거나 위험한 연산을 수행하는 경우 운영체제가 프로세스를 중지시키는 방법이 없다.

* 시스템 콜은 프로그램이 운영체제와 상호작용하여 프로그램이 올바르게 실행될 수 있도록 지원하며, 컴퓨터 시스템의 핵심 부분을 담당하는 중요한 역할을 한다.

### PCB와 Context Switching
* 프로세스는 컴퓨터 시스템에서 실행되는 프로그램의 인스턴스로, 여러 프로세스가 동시에 실행될 수 있고, 운영체제(OS)는 이러한 프로세스들을 관리하며, 이를 위해 각 프로세스의 상태와 정보를 저장하는 곳이 있다. 이를 Process Control Block(PCB)라고 한다.

* PCB에는 프로세스 식별자(Process ID), 프로세스 상태(Process State), 프로그램 계수기(Program Counter), CPU 레지스터 및 일반 레지스터, CPU 스케줄링 정보, 메모리 관리 정보, 입출력 상태 정보 등이 포함되며, PCB는 각 프로세스가 생성될 때마다 생성되고, 프로세스가 종료되면 PCB는 삭제된다.

* 프로세스 간 전환 시에는 Context Switching이 발생하며, 이는 현재 실행 중인 프로세스의 상태를 저장하고 다음으로 실행할 프로세스의 상태를 불러오는 과정을 의미하며, 이때 PCB가 사용되어 현재 프로세스의 정보를 저장하고 복원한다. Context Switching은 CPU 스케줄링을 통해 발생하며, 이 과정에서 프로세스 간의 전환이 이루어진다.

* Context Switching 비용은 프로세스 간 전환 시 발생하며, 커널에 현재 프로세스의 정보를 저장하고 다음 프로세스의 정보를 가져오는 작업으로 인해 발생한다. 이러한 비용을 최소화하기 위해 CPU 스케줄링을 조절하는 것이 중요하다.

* 또한, 쓰레드(Thread)도 Context Switching을 수행하며, 쓰레드는 프로세스 내에서 실행되는 작은 실행 단위로, 프로세스와 달리 스택 영역을 제외한 영역을 공유하기 때문에 Context Switching 비용이 적다.

* 요약하면, PCB는 프로세스 정보를 저장하는 자료구조로, Context Switching은 프로세스 간 전환 시 발생하며 PCB를 활용하여 상태를 저장하고 복원한다. 이를 통해 운영체제는 여러 프로세스와 쓰레드를 효율적으로 관리하고 실행한다.

### IPC(Inter Process Communication)
프로세스 간 통신(Inter-Process Communication, IPC)은 프로세스들 사이에 서로 데이터를 주고받는 행위를 의미하며, 이를 위한 방법과 경로를 제공한다. 프로세스들은 보통 독립적으로 실행되기 때문에 서로 영향을 주고 받지 않는다. 그러나 이 독립성으로 인해 통신이 어려워진다. 따라서 IPC라는 방법을 사용하여 프로세스 간 통신을 구현한다.

IPC는 다양한 방식을 사용한다.

1. **공유 메모리와 메모리 맵**: 프로세스 간 메모리를 공유하는 방식이다. 공유 메모리는 메모리 공간을 공유하여 데이터를 주고 받으며, 메모리 맵은 파일을 메모리에 매핑하여 데이터를 공유한다. 공유 메모리는 IPC 중 가장 빠르게 작동하지만 주의가 필요하다.

2. **메시지 전달 기법**: 프로세스 간의 메시지를 교환하는 방식으로, 시그널, 세마포어, 파이프, 소켓 등이 있다. 메시지 전달을 통해 프로세스 간 통신을 구현하며, 메시지의 충돌을 방지하기 위해 중간 매개체를 사용한다.

3. **PIPE**: 동일한 PPID(부모 프로세스 ID)를 가진 프로세스 간에 통신이 가능하며, 반이중 통신 방식을 사용한다. 파이프를 사용하면 한쪽은 쓰기만 가능하고 다른 한쪽은 읽기만 가능한데, 양방향 통신을 위해 두 개의 파이프를 사용해야 한다.

4. **Named PIPE(FIFO)**: 부모 프로세스와 무관하게 다른 프로세스 간 통신이 가능하며, 파이프의 이름을 사용하여 프로세스 간 통신한다. Named 파이프도 반이중 통신 방식을 사용한다.

5. **Message Queue**: 선입선출 자료구조를 가지는 통신설비로 커널에서 관리되며, 메시지 큐는 메모리 공간을 활용한다. 데이터에 라벨링을 하여 여러 프로세스가 동시에 데이터를 다룰 수 있도록 한다.

6. **소켓(Socket)**: 소켓을 통한 통신 방법으로, 서버와 클라이언트 간의 연결을 통해 데이터를 주고 받는다. 소켓을 사용하여 프로세스 간 통신을 구현하며, 도메인, 타입, 프로토콜을 지정해야 한다.

7. **Semaphore**: Semaphore는 프로세스 간 데이터 동기화와 보호를 위해 사용된다. 다른 IPC 설비들이 주로 프로세스 간 메시지 전송을 목적으로 하는 반면, Semaphore는 공유된 자원에 대한 동시 접근을 조절하고 보호하는 데 사용된다.

최근에는 AMQP(Advanced Message Queue Protocol)와 같은 프로토콜을 사용하는 미들웨어도 많이 사용된다. RabbitMQ와 Kafka와 같은 미들웨어는 Pub-Sub 구조로 작동하여 프로세스 간 결합도를 낮추고 메시지 전달을 보장한다.